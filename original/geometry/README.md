
# jpmMath - geometry - Geometric and Astronomical Calculations

This README file was generated by AI (directed by Joao Schuler - https://forum.lazarus.freepascal.org/index.php/topic,71128.msg554806.html)

## Table of Contents

*   [Overview](#overview)
*   [Program Details](#program-details)
    *   [arcircle.pas - Arc of Circle Parameters Calculation](#arcirclepas---arc-of-circle-parameters-calculation)
    *   [conical.pas - Conical Section Reduction](#conicalpas---conical-section-reduction)
    *   [conical1.pas - Conical Section from Five Points](#conical1pas---conical-section-from-five-points)
    *   [gceuler.pas - Euler's Circle of a Triangle](#gceulerpas---eulers-circle-of-a-triangle)
    *   [planets1.pas - Planetary Position Calculation](#planets1pas---planetary-position-calculation)
    *   [surface.pas - Polygon Surface Area Calculation](#surfacepas---polygon-surface-area-calculation)
    *   [triangle.pas - Triangle Resolution](#trianglepas---triangle-resolution)
*   [Key Procedures and Units](#key-procedures-and-units)
    *   [SolveSystem (in conical1.pas)](#solvesystem-in-conical1pas)
    *   [System2D (in gceuler.pas)](#system2d-in-gceulerpas)
    *   [Line2D (in gceuler.pas)](#line2d-in-gceulerpas)
    *   [Draw_Circle3P (in gceuler.pas)](#draw_circle3p-in-gceulerpas)
    *   [ATAN2 (in planets1.pas)](#atan2-in-planets1pas)

---

## Overview

The `geometry` folder of the `jpmMath` library provides a set of independent Pascal programs, each addressing a specific geometrical or astronomical problem. The programs are self-contained and demonstrate classical mathematical algorithms for tasks such as calculating arc parameters, reducing conic equations, finding conics from points, drawing Euler's circle, determining planetary positions, computing polygon surface areas, and resolving triangles.

---

## Program Details

### `arcircle.pas` - Arc of Circle Parameters Calculation

**Description:**
This program calculates the four main parameters of a circular arc: Radius (R), Curvilinear Abscissa (S), Chord (C), and Angle (T, in radians). It requires exactly two of these parameters as input, with the other two set to zero. Additionally, it computes the surface area of the angular sector and the surface area between the arc and the chord.

**Functionality:**
The program takes two known parameters out of four (Radius `R`, Curvilinear Abscissa `S`, Chord `C`, Angle `T` in radians) and calculates the remaining two. It also computes the surface area of the angular sector (`S1`) and the surface area between the arc and the chord (`S2`).

**Inputs:**
The program prompts the user to input values for R, S, C, and T. Exactly two of these must be non-zero.
*   `R`: Radius of the circle.
*   `S`: Curvilinear abscissa of the arc (arc length).
*   `C`: Length of the chord.
*   `T`: Angle of the arc in radians.

**Input Constraints:**
*   Angle `T` must be between `0` and `PI` (inclusive).
*   Chord `C` must be smaller than curvilinear abscissa `S` (if `S` is positive).
*   Curvilinear abscissa `S` must be smaller than `C * PI / 2` (if `C` is positive).
*   Curvilinear abscissa `S` must be smaller than `R * PI` (if `R` is positive).

**Outputs:**
If successful, the program displays:
*   `SUCCESS`: A boolean indicating if a solution was found.
*   Calculated `R`, `S`, `C`, `T`.
*   `S1`: Surface of the angular sector.
*   `S2`: Surface between the arc and the chord.

**Algorithms/Procedures:**
The core logic involves solving trigonometric equations based on which two parameters are provided. For cases where `S` and `C` are given, an iterative method (Newton-Raphson like iteration) is used to find the radius and angle.

**Sample Run (from source comments):**
```
             ARC OF CIRCLE
 -----------------------------------------
  Give two parameters between:
    R: radius of circle
    S: curvilinear abscissa
    C: chord
    T: angle of arc in radians
  The other two must be given as zero.
  The program then calculates the
  missing parameters and the two surfaces:
    S1: total surface of angular sector
    S2: surface between chord and arc s.
 -----------------------------------------
     R= 0
     S= 0
     C= 2
     T= 1

 SUCCESS: TRUE

 Radius              :    2.0858296429
 Curvilinear abscissa:    2.0858296429
 Chord               :    2.0000000000
 Angle (radians)     :    1.0000000000

 Surface of angular sector     :    2.1753426497
 Surface between arc and chord :    0.3448549280
```

**Real-World Applications/Problem Solving Ideas:**
*   **Civil Engineering**: Calculating arc lengths for roads, bridges, or curves in railway tracks given certain constraints (e.g., chord length and angle).
*   **Mechanical Design**: Determining dimensions of curved components or gears based on limited known parameters.
*   **Surveying**: Reconstructing missing arc information from field measurements.
*   **Architecture**: Designing curved structures or elements, ensuring specific aesthetic or functional properties.

### `conical.pas` - Conical Section Reduction

**Description:**
This program reduces a general Cartesian equation of a conical section, `ax^2 + 2bxy + cy^2 + 2dx + 2ey + f = 0`, to its canonical form and determines its characteristics. It identifies the type of conical (ellipse, hyperbola, parabola, circle, or degenerate forms) and provides details such as center coordinates, focus positions, axis lengths, symmetry directions, and eccentricity.

**Functionality:**
Given the coefficients `a, b, c, d, e, f` of a general second-degree equation, the program classifies the conical section and calculates its defining properties.

**Inputs:**
The user is prompted to input the coefficients `a, 2b, c, 2d, 2e, f` of the conical equation. Note that `2b, 2d, 2e` are requested, and the program internally divides them by two.

**Outputs:**
The program outputs the `Type` of the conical section and its specific characteristics:
*   **Ellipse:** Center, directions of major and minor axes, half-lengths of axes, foci coordinates, and eccentricity.
*   **Hyperbola (or Equilateral Hyperbola):** Center, directions of first and second axes, summit coordinates, foci coordinates, and eccentricity.
*   **Parabola:** Center (vertex), symmetry direction, focus coordinates, and parameter.
*   **Circle:** Center, radius, and eccentricity (which is 1 for a circle in this context for identification purposes).
*   **Degenerate Cases:** Indicates if the conical degenerates into one line, two lines, a single point, or if it is not a conical at all.

**Algorithms/Procedures:**
The reduction process involves calculating the discriminant `delta = ac - b^2`.
*   If `delta = 0`: Parabola (or degenerate parabola).
*   If `delta > 0`: Ellipse (or circle, or single point).
*   If `delta < 0`: Hyperbola (or two intersecting lines).
The program transforms coordinates to eliminate the `xy` term and then the linear terms, identifying the center and rotational transformation for the canonical form.

**Sample Run (from source comments):**
```
  REDUCTION OF CONICALS

    a  = 1
    2b = 2
    c  = 1
    2d = -13
    2e = -11
    f  = 32

  Type: Parabola

  Center:  x=0.999999  y=5.000000
  Symmetry direction:  x=1  y=-1
  Focus:   x=1.124999  y=4.875000
  Parameter:           0.35355339
```

**Real-World Applications/Problem Solving Ideas:**
*   **Physics**: Analyzing trajectories of projectiles or celestial bodies (e.g., orbits are often elliptical or hyperbolic).
*   **Optics**: Designing lenses and mirrors, which often have parabolic or hyperbolic cross-sections to focus light.
*   **Structural Engineering**: Understanding stress distribution in curved structures or arches, which can be modeled by conical sections.
*   **Computer Graphics**: Generating accurate representations of geometric shapes in CAD software or simulations.

### `conical1.pas` - Conical Section from Five Points

**Description:**
This program determines the Cartesian equation `ax^2 + bxy + cy^2 + dx + ey + f = 0` of a unique conical section that passes through five distinct given points.

**Functionality:**
The program takes the coordinates of five unique points and calculates the coefficients `a, b, c, d, e, f` of the conical equation that interpolates these points.

**Inputs:**
The user is prompted to input the `(x, y)` coordinates for five distinct points: `(x1, y1)` to `(x5, y5)`. All five points must be distinct.

**Outputs:**
The program outputs the calculated coefficients `a, b, c, d, e, f` of the conical equation. If no conical section can be found (e.g., points are not distinct or lead to a singular system), it reports "No conical found."

**Algorithms/Procedures:**
The problem of finding a conic through five points translates into solving a linear system of five homogeneous equations with six unknowns (the coefficients `a` through `f`). Since the equation can be scaled by any non-zero constant, there are effectively five independent unknowns.

The program solves this by making successive hypotheses:
1.  Assume `f=1`: The system becomes `x^2 a + xy b + y^2 c + x d + y e = -1`.
2.  If the determinant is zero (meaning `f` cannot be 1), then assume `e=1`: The system becomes `x^2 a + xy b + y^2 c + x d + f = -y`.
3.  This process continues, attempting `d=1`, `c=1`, `b=1`, and finally `a=1` if previous attempts fail.
The core of the solution lies in the `SolveSystem` procedure (see [Key Procedures and Units](#key-procedures-and-units)), which implements a **Gauss-Jordan method with full pivoting** to solve the `5x5` linear system. This method ensures robustness by finding the largest pivot element at each step, making it less susceptible to numerical instability.

**Sample Run (from source comments):**
```
    SEEK A CONICAL PASSING THROUGH 5 POINTS

        X1  Y1 = 0 2
        X2  Y2 = 1 5
        X3  Y3 = 5 77
        X4  Y4 = -4 50
        X5  Y5 = 2 14


  The coefficients of the conical ax2+bxy+cy2+dx+ey+f = 0 are:

   a =   1.500000
   b =   0.000000
   c =  -0.000000
   d =  -0.000000
   e =  -0.500000
   f =   1.000000
```

**Real-World Applications/Problem Solving Ideas:**
*   **Computer Vision**: Reconstructing 2D shapes of objects from detected feature points in an image.
*   **Robotics**: Path planning or trajectory generation for robots that need to follow curved paths defined by a set of control points.
*   **Reverse Engineering**: Determining the mathematical description of an existing curved surface by sampling points on it.
*   **Geographic Information Systems (GIS)**: Interpolating boundaries or features that follow natural curves based on surveyed points.

### `gceuler.pas` - Euler's Circle of a Triangle

**Description:**
This program graphically demonstrates the Euler's (or Nine-Point) Circle of a triangle, along with the circumscribed circle and Euler's Line. The program uses a simple graphical output to visualize these geometric concepts.

**Functionality:**
The program defines a triangle using three points (A, B, C) and then calculates and draws:
1.  The circumscribed circle (passing through A, B, C).
2.  The three midpoints of the triangle sides (these are three of the nine points of the Euler circle).
3.  The Euler's Circle passing through these three midpoints.
4.  Euler's Line, which connects the circumcenter (center of the circumscribed circle) and the nine-point center (center of Euler's Circle).
5.  Altitudes of the triangle (lines from vertex perpendicular to opposite side).

**Inputs:**
The triangle vertices (A, B, C) are hardcoded within the `BEGIN` block of the main program for demonstration.
*   `ax, ay`: Coordinates of vertex A.
*   `bx, by`: Coordinates of vertex B.
*   `cx, cy`: Coordinates of vertex C.
To change the triangle, these values must be modified directly in the source code.

**Outputs:**
The program generates a graphical output displaying:
*   Triangle ABC.
*   Circumscribed Circle and its center (marked with a cross).
*   Midpoints of the sides (used to define Euler's Circle).
*   Euler's Circle and its center (marked with a cross).
*   Euler's Line.
*   Altitudes of the triangle.

**Algorithms/Procedures:**
The program uses several key procedures (see [Key Procedures and Units](#key-procedures-and-units)):
*   `System2D`: Solves a 2D linear system.
*   `Line2D`: Determines line coefficients from two points.
*   `Draw_Line`: Draws a line segment.
*   `Draw_Circle3P`: Draws a circle passing through three points, internally using `System2D`.
Midpoint Calculation: The midpoints of the sides are calculated as the average of the coordinates of the two vertices forming the side.
Orthocenter/Altitudes: The orthocenter (intersection of altitudes) is implicitly used or calculated in the display of altitude lines. The altitude from a vertex to an opposite side is perpendicular to that side.

**Sample Run:**
A graphical output is generated, illustrating the triangle, its circumcircle, Euler's Circle, and Euler's Line.

**Real-World Applications/Problem Solving Ideas:**
*   **Educational Software**: Visualizing complex geometric theorems for students.
*   **Computer-Aided Design (CAD)**: Providing tools for constructing and analyzing geometric properties of shapes.
*   **Robotics/Navigation**: Calculating key geometric points or paths for navigation in a triangular space.
*   **Art and Design**: Creating geometric patterns and designs based on fundamental theorems.

### `planets1.pas` - Planetary Position Calculation

**Description:**
This program calculates the geocentric equatorial coordinates (Ascension and Declination) of a planet in our solar system for a specified date and Universal Time (UT). These coordinates are essential for astronomical observations, particularly for adjusting equatorial telescopes.

**Functionality:**
Given a date, hour, and a planet number, the program computes the planet's right ascension (Ascent) and declination in Earth's geocentric equatorial coordinate system.

**Inputs:**
The user is prompted to input:
*   `Date (D, M, Y)`: Day, Month, Year (e.g., `10 3 1982`).
*   `Hour UT`: Universal Time hour (e.g., `6`).
*   `Planet number`: An integer representing the desired planet:
    *   `1`: Mercury
    *   `2`: Venus
    *   `3`: Earth (used internally for calculations, not an output option)
    *   `4`: Mars
    *   `5`: Jupiter
    *   `6`: Saturn
    *   `7`: Uranus
    *   `8`: Neptune

**Outputs:**
The program outputs:
*   `Ascent`: The Right Ascension of the planet in Hours and Minutes (0 to 24 hours).
*   `Declination`: The Declination of the planet in Degrees and Minutes (-90 to 90 degrees, indicated as North 'N' or South 'S').

**Algorithms/Procedures:**
The calculations are based on ephemeris data and orbital mechanics, drawing from established astronomical formulas.
1.  **Julian Day Calculation:** The input date and time are converted into a fractional Julian Day relative to a base epoch (1901.0 in this case). This `t` value represents the time elapsed in years from a reference point.
2.  **Planetary Constants:** The program uses pre-defined constants (`A` array) for each planet, which include elements like mean longitude, longitude of perihelion, eccentricity, inclination, and semi-major axis. These constants describe the planet's average orbital characteristics.
3.  **`planet_coordinates(j: Integer)`:** This procedure iteratively solves Kepler's Equation (`M = E - e sin(E)`) to find the eccentric anomaly (`u` in the code, `E` in standard notation). This step is crucial for transforming mean anomaly (uniform angular motion) to true anomaly (actual position in orbit).
4.  **Heliocentric to Geocentric Conversion:** The program first calculates the heliocentric (Sun-centered) ecliptic coordinates of the chosen planet and Earth. Then, it transforms these to geocentric (Earth-centered) equatorial coordinates, which involve rotations based on the obliquity of the ecliptic.
5.  **`ATAN2` Function:** A custom `ATAN2` function (see [Key Procedures and Units](#key-procedures-and-units)) is provided to correctly calculate angles based on the signs of x and y components, ensuring the correct quadrant for Right Ascension and Declination.

**Sample Run (from source comments):**
To find the ascent and declination of planet Mars on March 10th, 1982 at 6h UT:
```
Date (D,M,Y): 10 3 1982
Hour UT: 6
Mercury: 1 Venus : 2 Mars   : 4 Jupiter: 5
Saturn : 6 Uranus: 7 Neptune: 8
Planet number: 4

Ascent     : 13 H  8 MN
Declination:  3 ° 45 MN S
```

**Real-World Applications/Problem Solving Ideas:**
*   **Amateur Astronomy**: Assisting amateur astronomers in finding celestial objects by providing their current coordinates for telescope pointing.
*   **Celestial Navigation**: Historically used for navigation by determining positions relative to celestial bodies.
*   **Astrology Software**: Providing fundamental planetary positions for astrological chart calculations.
*   **Space Mission Planning (Simplified)**: While simplified, the underlying principles are used in more complex ephemeris calculations for spacecraft trajectory design and orbital mechanics.

### `surface.pas` - Polygon Surface Area Calculation

**Description:**
This program calculates the internal surface area of a polygon defined by an ordered sequence of its vertices' coordinates. It is designed for simple, non-self-intersecting polygons.

**Functionality:**
The program takes a predefined set of polygon vertices and computes its enclosed area using the Shoelace Formula.

**Inputs:**
The program currently has hardcoded values for the number of points (`npoints = 13`) and the coordinates of these points in a `buffer` array.
To use it for a different polygon, the user needs to:
1.  Adjust the `NMAX` constant if the polygon has more than 50 points.
2.  Set the `npoints` variable to the actual number of vertices in the polygon.
3.  Populate the `buffer` array (`buffer[i,1]` for x-coordinate, `buffer[i,2]` for y-coordinate) with the coordinates of the polygon's vertices in order (clockwise or counter-clockwise). The last point should typically be the same as the first to close the polygon for the formula to work correctly (as seen in the example, `buffer[13,1]=3; buffer[13,2]=3;` which is the same as `buffer[1,1]=3; buffer[1,2]=3;`).

**Outputs:**
The program prints the calculated surface area of the polygon.

**Algorithms/Procedures:**
The program implements the **Shoelace Formula** (also known as Gauss's Area Formula or the Surveyor's Formula). For a polygon with vertices `(x1, y1), (x2, y2), ..., (xn, yn)`, the formula for the area `S` is:
`S = 0.5 * | (x1y2 - y1x2) + (x2y3 - y2x3) + ... + (xn y1 - yn x1) |`
The implementation uses an equivalent form that sums `(x_i + x_{i+1}) * (y_i - y_{i+1})` for `i` from `1` to `n-1`, and then takes the absolute value of the sum divided by 2. The explicit formula used in the code is:
`S = 0.5 * | sum_{i=1}^{n-1} (x_i + x_{i+1})(y_i - y_{i+1}) |`
where `(x_n, y_n)` is effectively treated as `(x_1, y_1)` to close the polygon's loop in the summation.

**Sample Run (from source comments):**
Given `npoints=13` and the hardcoded coordinates:
```
npoints=13
x1=3    y1=3
x2=12   y2=3
x3=12   y3=6
x4=11   y4=6
x5=11   y5=7
x6=15   y6=7
x7=15   y7=9
x8=8    y8=9
x9=8    y9=6
x10=4   y10=6
x11=4   y11=9
x12=3   y12=9
x13=3   y13=3

Surface is: 4.70000000000000E+0001  (which is 47.0)
```

**Real-World Applications/Problem Solving Ideas:**
*   **Geographic Information Systems (GIS):** Calculating land areas, property boundaries, and zoning regions from digitized maps or GPS data.
*   **Civil Engineering:** Estimating material quantities for construction projects involving irregular land plots.
*   **Game Development:** Determining areas for collision detection, pathfinding on complex terrains, or calculating resource distribution zones.
*   **Computer-Aided Design (CAD):** Computing the area of complex shapes in architectural plans or mechanical drawings.
*   **Surveying:** Rapidly calculating areas from field measurements.

### `triangle.pas` - Triangle Resolution

**Description:**
This program resolves a triangle by determining its missing elements (sides and angles) and calculating its surface area, given any three of its six elements (three sides A, B, C, and three opposite angles TA, TB, TC). It can also identify and display a second possible triangle solution if the input data leads to an ambiguous case (e.g., SSA - Side-Side-Angle).

**Functionality:**
Given any three non-zero elements of a triangle (sides or angles), the program computes the remaining three elements and the triangle's surface area. It also handles cases where two solutions exist.

**Inputs:**
The user is prompted to input three non-zero elements out of the six (A, B, C, TA, TB, TC). The other three must be entered as zero.
*   `Side A`, `Side B`, `Side C`: Lengths of the sides.
*   `Angle unit: PI = `: This input determines if angles are in degrees (e.g., `180`) or radians (e.g., `3.1415926535`). The program internally converts them to radians using this value.
*   `TA`, `TB`, `TC`: Angles opposite to sides A, B, and C respectively.

**Outputs:**
If a solution is found, the program displays:
*   The resolved lengths of sides `A`, `B`, `C`.
*   The resolved angles `TA`, `TB`, `TC` (in the specified unit).
*   The `Surface` area of the triangle.
If the input data is inconsistent or no solution can be found, it outputs "Wrong data or no solution found."
If there are two possible solutions (ambiguous case), it first displays the first solution and then, upon user input, displays the second solution.

**Algorithms/Procedures:**
The `Triangle1` function (internal to the program) performs the core logic for solving the triangle. It first preprocesses the inputs by indexing the given sides and angles.
1.  **Data Consistency Check:** Validates that angles are between `0` and `PI` and sides are positive. It also checks that the sum of given angles does not exceed `PI` and that exactly three elements are non-zero.
2.  **Case Handling:** The resolution logic is based on the number of sides given:
    *   **One Side Given (e.g., ASA, AAS):** Uses the Law of Sines to find the missing sides after calculating the third angle (since the sum of angles in a triangle is `PI`).
    *   **Two Sides Given (e.g., SAS, SSA):**
        *   **SAS (Side-Angle-Side):** If the angle between the two given sides is known, the Law of Cosines is used to find the third side. The Law of Sines or Law of Cosines is then applied to find the remaining angles.
        *   **SSA (Side-Side-Angle - Ambiguous Case):** If two sides and a non-included angle are given, there might be zero, one, or two possible triangles. The program uses trigonometric relationships to determine the possibilities and flags the `two` boolean variable if two solutions exist.
    *   **Three Sides Given (SSS):** Checks the triangle inequality (sum of any two sides must be greater than the third). If valid, the Law of Cosines is used to calculate all three angles.
3.  **Surface Area Calculation:** After all sides are determined, the surface area `s` is calculated using **Heron's Formula**: `s = sqrt(r * (r-a) * (r-b) * (r-c))`, where `r` is the semi-perimeter `(a+b+c)/2`.

**Sample Run (from source comments):**
```
                 RESOLUTION OF A TRIANGLE

 Give three side or angle elements out of six. The other elements
 must be given as zero.  The program  will determine  the missing
 elements and display results.

      Side A = 18
      Side B = 0
      Side C = 0

      Angle unit: PI = 180

      TA (angle opposite to side A) = 0
      TB (angle opposite to side B) = 110
      TC (angle opposite to side C) = 52.2


  A  =       18.0000000000
  B  =       55.3311316842
  C  =       46.5260342304

  TA =       17.8000000000
  TB =      110.0000000000
  TC =       52.2000000000

  Surface:      393.4815393691
```

**Real-World Applications/Problem Solving Ideas:**
*   **Surveying and Land Management**: Calculating unknown distances, angles, and areas of land parcels from limited measurements.
*   **Navigation**: Determining distances and bearings in various navigation contexts (e.g., marine, aerial).
*   **Civil Engineering**: Analyzing forces and dimensions in truss structures, bridge design, and other static systems.
*   **Architecture**: Designing and calculating dimensions for roof structures, building facades, and other geometric elements.
*   **Robotics**: Path planning for robotic arms or mobile robots that need to move within triangular workspaces.
*   **Education**: A practical tool for students to explore and solve triangle problems in trigonometry and geometry.

---

## Key Procedures and Units

This section highlights important reusable procedures found within the `geometry` library that perform fundamental mathematical operations, enabling developers to build upon these foundational components.

### SolveSystem (in conical1.pas)

**Description:**
A generic procedure for solving a linear matrix system of the form `AX = B` using the Gauss-Jordan elimination method with full pivoting. It is designed to work for `N x N` matrix `AA` and `N x M` matrix `BB`.

**Functionality:**
It modifies the input matrices `AA` (to its inverse) and `BB` (to the solution matrix `X`). It also calculates the determinant of `AA`. It handles potential singularity by checking if the determinant falls below a machine epsilon (`EPSMACH=2E-16`).

*   **Parameters:**
    *   `N`: Dimension of the square matrix `AA`.
    *   `M`: Number of columns in the `BB` matrix (number of right-hand side vectors).
    *   `VAR AA: MAT5`: The input `N x N` matrix, which will be replaced by its inverse. (Note: currently limited to `N=5` by `MAT5` type).
    *   `VAR BB: VEC5`: The input `N x M` matrix (or vector if `M=1`), which will be replaced by the solution `X`. (Note: currently limited to `M=1` by `VEC5` type).
    *   `VAR DET: DOUBLE`: Output parameter for the determinant of `AA`.

**Real-World Applications/Problem Solving Ideas:**
*   **Any Linear System:** Applicable to any problem that can be modeled as a system of linear equations, which is fundamental in many scientific and engineering fields.
*   **Least Squares Fitting:** Solve for parameters in linear regression models.
*   **Circuit Analysis:** Determine currents and voltages in electrical circuits.
*   **Numerical Methods:** Serve as a building block for more complex numerical algorithms.

### System2D (in gceuler.pas)

**Description:**
A specialized procedure to solve a 2x2 linear system of the form:
`a x + b y = c`
`a1 x + b1 y = c1`

**Functionality:**
It directly applies Cramer's rule-like formulas to find `x` and `y`. It checks for singular systems (where `b*a1 - a*b1` is close to zero).

*   **Parameters:**
    *   `a, b, c, a1, b1, c1: real_ar`: Coefficients of the linear system.
    *   `Var x, y: real_ar`: Output parameters for the solution `x` and `y`.

**Real-World Applications/Problem Solving Ideas:**
*   **Intersection of Lines:** Find the intersection point of two straight lines.
*   **Geometric Calculations:** Determine coordinates of centers in geometric constructions (e.g., circumcenter of a triangle, as used in `Draw_Circle3P`).
*   **Simple Physics Problems:** Solve for two unknown variables in scenarios with two linear relationships.

### Line2D (in gceuler.pas)

**Description:**
Determines the coefficients `a` and `b` for a straight line equation `y = ax + b` that passes through two given points `(x1, y1)` and `(x2, y2)`.

**Functionality:**
It implicitly uses `System2D` to solve for `a` and `b` by setting up the linear system:
`x1 * a + 1 * b = y1`
`x2 * a + 1 * b = y2`

*   **Parameters:**
    *   `x1, y1, x2, y2: real_ar`: Coordinates of the two points.
    *   `Var a, b: real_ar`: Output parameters for the slope `a` and y-intercept `b`.

**Real-World Applications/Problem Solving Ideas:**
*   **Equation of a Line:** Find the equation of a line given two points.
*   **Linear Interpolation:** Calculate intermediate values along a line segment.
*   **Trajectory Analysis:** Model simple linear movements.

### Draw_Circle3P (in gceuler.pas)

**Description:**
Draws a circle passing through three given points `(x1, y1), (x2, y2), (x3, y3)`.

**Functionality:**
It derives the center `(a, b)` and radius `r` of the circle from the three points by solving a linear system (using `System2D`) based on the general circle equation `x² + y² - 2ax - 2by + c = 0`. It then calls a `Circle` procedure (from `Graph_2d` unit, assumed to be available in the environment) to render the circle.

*   **Parameters:**
    *   `x1, y1, x2, y2, x3, y3: Real_ar`: Coordinates of the three points.

**Real-World Applications/Problem Solving Ideas:**
*   **Computer Graphics:** Drawing circles that fit specific points.
*   **Geometric Design:** Creating circular features that pass through critical locations.
*   **Collision Detection (Simplified):** Define bounding circles based on three extreme points.

### ATAN2 (in planets1.pas)

**Description:**
A custom implementation of the `ATAN2` function, which computes the arctangent of `y/x` using the signs of both arguments to determine the correct quadrant of the angle.

**Functionality:**
Returns an angle in radians, in the range `(-PI, PI]`, that is the angle between the positive x-axis and the point `(x, y)`. It handles cases where `x` is zero.

*   **Parameters:**
    *   `y: Double`: The y-coordinate.
    *   `x: Double`: The x-coordinate.

*   **Returns:**
    *   The angle in radians.

**Real-World Applications/Problem Solving Ideas:**
*   **Vector Math:** Calculate the angle of a 2D vector.
*   **Coordinate Transformations:** Convert Cartesian coordinates to polar coordinates.
*   **Robotics/Navigation:** Determine bearing or heading angles.
*   **Celestial Mechanics:** Convert celestial coordinates, as seen in `planets1.pas`.

